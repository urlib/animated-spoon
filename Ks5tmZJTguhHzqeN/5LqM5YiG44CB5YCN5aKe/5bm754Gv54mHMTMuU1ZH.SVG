<svg width="1280" height="720" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="hidden"><defs><clipPath id="clip0"><path d="M0 0 1280 0 1280 720 0 720Z" fill-rule="evenodd" clip-rule="evenodd"/></clipPath></defs><g clip-path="url(#clip0)"><rect x="0" y="0" width="1280" height="720" fill="#FFFFFF"/><text font-family="Arial,Arial_MSFontService,sans-serif" font-weight="400" font-size="37" transform="translate(97.6 104)">•<tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="24" y="0">首先发现当没有清空的时候每次向后增加</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="696" y="0">K</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="716.667" y="0">都不会减小，所以对</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="24" y="41">于不清空来说</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="248" y="41">K</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="268.667" y="41">一定是非递减的</tspan><tspan x="0" y="94">•</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="24" y="94">定义左端点</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="210.667" y="94">L</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="228" y="94">二分寻找每个右端点</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="564" y="94">R</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="585.5" y="94">，保证现在</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="772.167" y="94">R</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="793.667" y="94">是</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="831" y="94">[L,R]</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="899.667" y="94">第一个大</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="24" y="135">于</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="61.3333" y="135">M</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="93.6667" y="135">的位置，寻找内部是直接排序暴力</tspan><tspan x="0" y="188">•</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="24" y="188">但是会超时，因为可能每个</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="472" y="188">R</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="493.5" y="188">都离</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="568.167" y="188">L</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="585.5" y="188">不远，这样每次减去的数字就</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="24" y="229">很少</tspan><tspan x="0" y="282">•</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="24" y="282">我们考虑另一种二分，首先根据</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="546.667" y="282">L</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="564" y="282">暴力找到</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="713.333" y="282">p</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="734.833" y="282">，使</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="809.5" y="282">[L,2^P]</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="921.833" y="282">是第一个</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="24" y="323">大于</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="98.6667" y="323">M</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="131" y="323">的位置，这儿最多是暴力</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="541.667" y="323">logn</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="613.333" y="323">次，而且当</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="800" y="323">2^p</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="866" y="323">不是很大时，</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" font-weight="700" x="24" y="363">每次暴力内部都很快（</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" font-weight="700" x="397.333" y="363">[L,2^p]</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" font-weight="700" x="518.333" y="363">数字少）</tspan><tspan x="0" y="417">•</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="24" y="417">接着二分寻找</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="248" y="417">[L,2^(p</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="361.167" y="417">-</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="379.833" y="417">1)]</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="421.167" y="417">与</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="458.5" y="417">[L,2^p]</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="571.667" y="417">中最小的</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="721" y="417">R</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="742.5" y="417">满足</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="817.167" y="417">[L,R]</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="885.833" y="417">第一个大于</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="24" y="457">M</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="56.3333" y="457">，这儿减去的数字少的话也很快，减去的多等等循环的次数就</tspan><tspan font-family="DengXian,DengXian_MSFontService,sans-serif" x="24" y="497">少了</tspan></text></g></svg>