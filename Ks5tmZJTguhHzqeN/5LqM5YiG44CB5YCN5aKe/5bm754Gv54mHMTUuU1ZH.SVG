<svg width="1280" height="720" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="hidden"><defs><clipPath id="clip0"><path d="M0 0 1280 0 1280 720 0 720Z" fill-rule="evenodd" clip-rule="evenodd"/></clipPath></defs><g clip-path="url(#clip0)"><rect x="0" y="0" width="1280" height="720" fill="#FFFFFF"/><text font-family="DengXian,DengXian_MSFontService,sans-serif" font-weight="400" font-size="32" transform="translate(97.6 88)">二分时间<tspan x="0" y="44">然后一个显然的事是一个军队向上爬的越高它控制的点越多</tspan><tspan x="0" y="88">所以首先军队尽量往上爬。</tspan><tspan x="0" y="132">当一个军队可以爬到根节点我们记录下它的剩余时间</tspan><tspan x="736" y="132">T</tspan>和它到达根结点时经过<tspan x="0" y="163">的根节点的子节点</tspan>son。<tspan x="0" y="207">当一个军队爬不到根节点时我们就让它控制它可以爬到的最高点。</tspan><tspan x="0" y="251">然后我们把爬到根节点的军队按</tspan><tspan x="448" y="251">T</tspan>从小到大排序。<tspan x="0" y="295">然后按顺序处理</tspan><tspan x="0" y="339">然后假如一个军队没有时间回到它的</tspan><tspan x="512" y="339">son</tspan>，且son还没有控制。就让它控制son。<tspan x="0" y="383">因为让别的军队去控制它显然更浪费时间。</tspan><tspan x="0" y="427">否则贪心地匹配就好了（尽量小的和小的和匹配）</tspan><tspan x="0" y="471">然后向上爬用倍增来优化。</tspan></text></g></svg>